---
layout: single
title: "컬렉션 조회 최적화"
categories: StudyJPA-Application
toc: true
author_profile: true
sidebar:
    nav: "docs"
---

# 주문조회 V1: 엔티티 직접 노출
````java
@RestController
@RequiredArgsConstructor
public class OrderApicontroller{

    private final OrderRepository orderRepository;

    @GetMapping("api/v1/orders")
    public List<Order> ordersV1(){
        List<Order>all = orderRepository.findAll();
        for (Order order : all) {
            order.getMember().getName();
            order.getDelivery().getAddress();
            List<OrderItem> orderItems = order.getOrderItems();
            orderItems.stream()
            .forEach(o-> o.getItem().getName());
        }
        return all;
    }
}

/* 양방향 연관관계면 무한 루프에 걸리지 않게 한곳에 @JsonIgnore를 추가해야 한다.

엔티티를 직접 노출하므로 좋은 방법은 아니다. */
````

<br>

# 주문 조회V2 : 엔티티를 DTO로 변환
````java
@GetMapping("/api/v2/orders")
public List<OrderDto> ordersV2(){
    List<Order> orders = orderRepository.findAll();
    List<OrderDto> result = orders.stream()
    .map(o-> new OrderDto(o))
    .collect(toList());

    return result;
}

//OrderApiController에 추가//
@Data
static class OrderDto {
    private Long orderId;
    private String name;
    private LocalDateTime orderDate;
    private OrderStatus orderStatus;
    private Address address;
    private List<OrderItemDto> orderItems;

    public OrderDto(Order order){
        orderId = order.getId();
        name = order.getMember().getName();
        orderDate = order.getOrderDate();
        orderStatus = order.getStatus;
        address = order.getDelivery().getAddress();
        orderItems = order.getOrderItems().steam()
        .map(orderItem -> new OrderItemDto(orderItem))
        .collect(toList());
    }
}

@Data
static class OrderItemDto{
    private String itemName;
    private int orderPrice;
    private int count;

    public OrderItemDto(OrderItem orderItem){
        itemName = orderItem.getItem().getName();
        orderPrice = orderItem.getOderPrice();
        count = orderItem.getCount();
    }
}
// 지연 로딩으로 너무 많은 SQL실행//
````

<br>

# 주문 조회 V3: 엔티티를 DTO로 변환 - 페치 조인 최적화
````java
@GetMapping("/api/v3/orders")
    public List<OrderDto> ordersV3() {
        List<Order> orders = orderRepository.findAllWithItem();
        List<OrderDto> result = orders.stream()
                .map(o -> new OrderDto(o))
                .collect(toList());
        return result;
    }

//OrderRepository에 추가//
public List<Order> findAllWithItem() {
        return em.createQuery(
        "select distinct o from Order o" +
        " join fetch o.member m" +
        " join fetch o.delivery d" +
        " join fetch o.orderItems oi" +
        " join fetch oi.item i", Order.class)
.getResultList();
}

//페치 조인으로 SQL이 1번만 실행됨//
//distinct 를 사용한 이유는 일대다 조인이 있으므로 데이터베이스 row가 증가한다. 
//컬렉션 페치 조인 때문에 중복 조회 되는 것을 막아준다.//
//페이징 불가능//
````

<br>

# 주문 조회 V3.1: 엔티티를 DTO로 변환 - 페이징과 한계 돌파
````java
public List<Order> 
findAllWithMemberDelivery(int offset, int limit) {
      return em.createQuery(
        "select o from Order o" +
        " join fetch o.member m" +
        " join fetch o.delivery d", Order.class)
.setFirstResult(offset)
.setMaxResults(limit)
.getResultList();

//OrderApiController에 추가//
@GetMapping("/api/v3.1/orders")
  public List<OrderDto> ordersV3_page
  (@RequestParam(value = "offset",
   defaultValue = "0") 
   int offset, @RequestParam(value = "limit",
    defaultValue = "100") int limit) {
      
      List<Order> orders = 
      orderRepository.findAllWithMemberDelivery(offset,limit);
      List<OrderDto> result = orders.stream()
              .map(o -> new OrderDto(o))
      .collect(toList());
      return result;
    }

//최적화 옵션//
 spring: jpa:
        properties:
          hibernate:
            default_batch_fetch_size: 1000
//개별로 적용하려면  @BatchSize 적용//
````

장점

쿼리호출수가1+N 1+1로최적화된다.

조인보다 DB 데이터 전송량이 최적화 된다. 

페이징 가능

단점

ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고 해결하고, 나머지는 hibernate.default_batch_fetch_size 로 최적화.
